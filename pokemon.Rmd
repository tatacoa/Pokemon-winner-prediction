---
title: "Pokemon Winner Prediction"
author: "Ana Maria, Arturo, Shuaib, Viktor"
date: "13/01/2019"
output:
  html_document:
    code_folding: hide
    theme: lumen
    toc: yes
  pdf_document:
    toc: yes
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.width=12, fig.height=8) 
```

## 1 Introduction

"Pokemon are fantasy creatures in the series of video games of the same name. The games were originally developed by Satoshi Tajiri and the Japanese game software company GAME FREAK Inc. and represent one of the most important franchises of the publisher Nintendo. The Pokémon can be captured, collected and trained by the player. The success of the game, which was first released in 1996, was followed by an anime television series, a trading card game, a large number of merchandising products and, since 1998, 21 feature films. The video games of the Pokémon franchise have sold more than 200 million copies worldwide"  [@Wikipedia]


### 1.1 The Task
The task is to model the pokemon dataset using supervised learning methods. Our goal is to predict the probability of winning for a Pokemon. We will use two regression models to do that. First we will use Linear regression (Ridge and Lasso), and second we will use Decision Tree. The pre-processed data will be divided into 60% train, 20% Validation and 20% test data. 


### 1.2 The Tools
In the process of the group work, we have been using Github and R Studio. With Github we were able to share our R scripts. R Studio has been the choice of our local working environment due to the fact that all lectures have been complemented with R Studio. Hence the environment was known to each team member. 

### 1.3 The Data
The two dataset used in the project were obtained from Nintendo's famous original Pokemon video game.

The pokemon dataset contains a full set of in-game statistics for 800 pokemon in the 6 generations of video games form the Pokemon world. It also includes full information on pokemon description, power, type and from wich generation it belongs (pokemon.csv).

The combats dataset is a collection of 50.000 combats between two pokemon and the winner of the figth (combats.csv). 

```{r, include=FALSE}
setwd("~/Documents/Pokemon-winner-prediction")
pokemon <- read.csv('./data/pokemon.csv')
fights <- read.csv('./data/combats.csv')
```

```{r load, include=FALSE}
# Load required Libraries
library(ggplot2)
library(dplyr)
library(gridExtra)
library(corrplot)
library(caret)
library(ggthemes)
library(RColorBrewer)
library(fmsb)
library(rpart.plot)
library(ROCR)
library(ggplot2)
```

#### 1.3.1 Pokemon Dataset

| Column     | Description                                                                            |
|------------|----------------------------------------------------------------------------------------|
| X.         | ID for each pokemon                                                                    |
| Name       | Name of each pokemon                                                                   |
| Type 1     | Each pokemon has a type, this determines weakness/resistance to attacks                |
| Type 2     | Some pokemon are dual type and have 2                                                  |
| HP         | hit points, or health, defines how much damage a pokemon can withstand before fainting |
| Attack     | the base modifier for normal attacks (eg. Scratch, Punch)                              |
| Defense    | the base damage resistance against normal attacks                                      |
| SP Atk     | special attack, the base modifier for special attacks (e.g. fire blast, bubble beam)   |
| SP Def     | the base damage resistance against special attacks                                     |
| Speed      | determines which pokemon attacks first each round                                      |
| Generation | Video game version                                                                     |
| Legendary | if the Pokemon is legendary or not                                                                     |
Pokemon generation refers to a chronological division by release; The fisrt generation of the video game came up in 1996 "Pokemon Red and Green" for Game Boy [@Wikipedia], each new generation brings to live new Pokemon, characters and features. In the dataset there are Pokemon from 6 generations.

```{r generations, fig.height = 3, fig.width = 5}
print('Pokemon Generation')
table(pokemon$Generation)
barplot(table(pokemon$Generation), col=heat.colors(6), main = 'Pokemon Generation', xlab = 'Generation', ylab = 'Count')
```

Type 1 and type 2 refers to the main trait or element that the Pokemon possesses. Some pokemon have two main traits, while others only have one. Having several types of traits can present an advantage for the Pokemon at the moment of a fight.


```{r types1, fig.height = 3, fig.width = 5}
print('Pokemon Type 1')
sort(table(pokemon$Type.1))
par(las=2)

barplot(sort(table(pokemon$Type.1)), 
        col = heat.colors(length(unique(pokemon$Type.1))), 
        main = 'Type 1 Pokemon',
         ylab = 'Count')
```
The most common type of pokemon is the water type with 112 pokemon, followed by Normal type 98 pokemon and Grass type 70 pokemon. The least common type 1 among the 800 pokémon is the Flying type with only 4 pokémon. 

```{r types2, fig.height = 3, fig.width = 5}
par(las=2)
print('Pokemon Type 2')
sort(table(pokemon$Type.2))
barplot(sort(table(pokemon$Type.2)), 
        col = heat.colors(length(unique(pokemon$Type.2))), 
        main = 'Type 2 Pokemon', ylab = 'Count')
```

For 386 pokemon there is no type 2 registered. This simply indicates that for these pokemones there is only one type of element in which they are strong. Another interesting fact is that the type flying for type 1 is very rare, but for type 2 is one of the most common. 

The Pokemon table has a dimension of:
```{r}
dim(pokemon)
```
The columns name as described before are:
```{r}
names(pokemon)
```
This is how the data look like:
```{r}
head(pokemon)
```
There are no missing values in the Pokemon dataset.
```{r}
colSums(is.na(pokemon))
```
 
#### 1.3.2 Combat Dataset

| Column         | Description                |
|----------------|----------------------------|
| First_pokemon  | Pokemon that attack first  |
| Second_pokemon | Pokemon that attack second |
| Winner         | Winner of the combat       |

The entries in combat.csv are the ids of the Pokemon found in pokemon.csv, later we will make a data handling to this dataset to change the ids to Pokemon names in order to have a better understanding.

The Pokemon table has a dimension of:
```{r}
dim(fights)
```
The columns name as described before are:
```{r}
names(fights)
```
This is how the data look like:
```{r}
head(fights)
```
There are no missing values in the Pokemon dataset.
```{r}
colSums(is.na(fights))
```
This combat dataset contains fifty thousand battles between pokemon and its corresponding winner. Here we have grouped by winner.
```{r data_figths}
print('Winner Table')
wins <- group_by(fights, Winner)
summarise(wins, count = n())
```

Up to this point, we have presented the data, we also indicated the purpose of this report will be to predict the probability of winning for a pokemon using two regression models (Linear regression and decision trees) and finally we will choose which model is more suitable for our data.

## 2 Exploratory Data Analysis

Before modeling our data. The first step is to make a descriptive analysis of the dataset. 

### 2.1 Data Visualization

#### 2.1.1 Data Correlation
To check for any statistical association between the pokemon features we perform a correlation plot. 

```{r data_cor}
# visualization
# feature correlation
featCorr <- cor(select(pokemon, HP, Attack, Defense, Sp..Atk, Sp..Def, Speed )) # correlation table for features
corrplot(featCorr, method = "color", type = "upper", addCoef.col = "black", tl.col = "black", diag = FALSE)
```

When looking at the correlation plot, there is no strong correlation (greater than 0.80) between two features, even the highest correlation is between Defense vs. Sp..Def and Sp..Atk vs..Def which in both cases is 0.51 a positive correlation. The cor values indicates how close two variables are to having a linear relationship with each other [@Wikipedia]. 

Testing for Correlations is useful because they can indicate dependency and highly correlated variables are not desired at the moment of modeling (test for independence).

#### 2.1.2 Feature Distribution by Pokemon Type
```{r data_Type}
# plot specific feature distribution by Pokemon type
par(las=2)
boxplot(HP ~ Type.1,
        data=pokemon,
        main="Hit points Range by Pokemon Type",
        xlab="Type 1",
        ylab="Hit points",
        col="grey",
        border="brown"
)
par(las=2)
boxplot(Attack ~ Type.1,
        data=pokemon,
        main="Attack Range by Pokemon Type",
        xlab="Type 1",
        ylab="Attack",
        col="red",
        border="brown"
)
par(las=2)
boxplot(Defense ~ Type.1,
        data=pokemon,
        main="Defense Range by Pokemon Type",
        xlab="Type 1",
        ylab="Defense",
        col="orange",
        border="brown"
)

```

#### 2.1.3

The sum of all the numerical features is a good indication of how strong a pokemon is. Next there is a plot that brings together all the numerical characteristics of the Pokemon dataset, and shows which type of Pokemon is the strongest, and therefore most likely to win a battle. 

```{r data_pokemon_char}
# set color for each pokemon type for plotting // hex codes from http://www.epidemicjohto.com/t882-type-colors-hex-colors
color<-c("#6F35FC","#B7B7CE","#A98FF3","#F95587","#B6A136","#EE8130","#F7D02C","#705746","#735797","#E2BF65","#96D9D6","#6390F0","#7AC74C","#C22E28","#D685AD","#A33EA1","#A8A77A","#A6B91A")

# pokemon characteristics
#res<-data.frame(pokemon %>% dplyr::select(Type.1,HP, Attack, Defense, Sp..Atk, Sp..Def, Speed) %>% dplyr::group_by(Type.1) %>% dplyr::summarise_all(funs(mean)) %>% mutate(sumChars = HP + Attack + Defense + Sp..Atk + Sp..Def + Speed) %>% arrange(-sumChars))
res <- select(pokemon, Type.1, HP, Attack, Defense, Sp..Atk, Sp..Def, Speed) # select particular features
res <- group_by(res, Type.1) # group by pokemon type
res <- summarise_all(res, funs(mean)) # get mean values for the types
res <- mutate(res, sumChars = HP + Attack + Defense + Sp..Atk + Sp..Def + Speed) # sum up all mean values
res <- arrange(res, -sumChars) # sort for values, descending
res$color<-color # apply color scheme
max<- ceiling(apply(res[,2:7], 2, function(x) max(x, na.rm = TRUE)) %>% sapply(as.double)) %>% as.vector
min<-rep.int(0,6)

par(mfrow=c(3,6))
par(mar=c(1,1,1,1))
for(i in 1:nrow(res)){
  curCol<-(col2rgb(as.character(res$color[i]))%>% as.integer())/255 # convert to rgb
  radarchart(rbind(max,min,res[i,2:7]),
             axistype=2 , 
             pcol=rgb(curCol[1],curCol[2],curCol[3], alpha = 1) ,
             pfcol=rgb(curCol[1],curCol[2],curCol[3],.5) ,
             plwd=2 , cglcol="grey", cglty=1, 
             axislabcol="black", caxislabels=seq(0,2000,5), cglwd=0.8, vlcex=0.8,
             title=as.character(res$Type.1[i]))
}
```

The plots are sorted from strongest to weakest in relation to the sum of their characteristics.The Dragon Type pokémon are the strongest and the Bug Type pokémon are the weakest.

### 2.2 Data Preprocessing for Modeling

To start the data pre-processing, we found a pokemon that didn't have his name. It is the Primeape pokemon and we added it to the pokemon table.

```{r}
levels(pokemon$Name)[levels(pokemon$Name)==""] <- "Primeape" # pokemon name was not given
```

Create an object called names that contain only pokemon id and pokemon name.
```{r}
names <- pokemon[,c(1,2)]; head(names) # join id with pokemon name
colnames(names)

```

We use the new object 'names' to map the corresponding Id in the combat dataset. After mapping the names into the dataset we observ that only 784 out of 800 Pokemon fougth (in our dataset).
```{r}
#Map the figths table from id to pokemon name
fights.name <- data.frame(lapply(fights, function(x) names$Name[match(x,names$X.)]))
head(fights.name)
```

From the 784 that fought in a battle one of them never won.
```{r}
sapply(fights.name, function(x) length(unique(x))) # only 784 of 800 pokemon fought
```

next step was to write a function to get the number of times a pokemon won, a pokemon attak first and a pokemon attak second from the combat dataset.
```{r}
get_win_table <- function() {
  counts <- group_by(fights.name, Winner)
  count_table <- summarise(counts, count = n())
  return(count_table)
}

get_firsts_table <- function() {
  counts <- group_by(fights.name, First_pokemon)
  count_table <- summarise(counts, count = n())
  return(count_table)
}

get_seconds_table <- function() {
  counts <- group_by(fights.name, Second_pokemon)
  count_table <- summarise(counts, count = n())
  return(count_table)
}

win_table <- get_win_table()
firsts_table <- get_firsts_table()
seconds_table <- get_seconds_table()
```

The next step was to add the combats table information into the pokemon table. To do this we counted the number of times a pokemon fought, won, attacked first or second and added it to the pokemon table.

```{r}
win_counts <- sapply(pokemon$Name, function(x) win_table$count[match(x,win_table$Winner)])
first_counts <- sapply(pokemon$Name, function(x) firsts_table$count[match(x,firsts_table$First_pokemon)])
second_counts <- sapply(pokemon$Name, function(x) seconds_table$count[match(x,seconds_table$Second_pokemon)])

pokemon_feats <- cbind(pokemon, win_counts, first_counts, second_counts)
pokemon_feats$losses <- pokemon_feats$first_counts + pokemon_feats$second_counts - pokemon_feats$win_counts

pokemon_feats$win_ratio <- pokemon_feats$win_counts / (pokemon_feats$second_counts + pokemon_feats$first_counts)
head(pokemon_feats)
```

And finally we save this file as "features.csv"
```{r}
write.csv(pokemon_feats, file="./features.csv")
```

### 2.3 Hot Encoding Categorical Data
For the hot encoding we are going to continue with the dataset we created in section 2.2. We load the file and check again for any missing value.
```{r}
feats <- read.csv('./data/features.csv')
colSums(is.na(feats))
```
We know that not all the pokémon fought and that's why we have missing values. to continue with the model we will eliminate all the row with missing values.
```{r}
feats2 <- feats[-(which(is.na(feats$win_ratio))),]
dim(feats2)
colnames(feats2)
```
we also found that the column of Id X. is duplicated, and for the hot encoding we don't need the name of the pokemon. we take them out of the dataset.
```{r}
feats2 <- feats2[,c(4:18)]; head(feats2); 
dim(feats2)
```
Now we must distinguish between numerical and categorical features, for this we create an object with all the features and their class. and we create another object that includes only the numerical features colnames and the same for categorical features.
```{r}
feature_classes <- sapply(names(feats2),function(x){class(feats[[x]])})
feature_classes
numeric_feats <-names(feats2[feature_classes != "character" &
                      feature_classes != "factor"])
numeric_feats
categorical_feats <- names(feats2[feature_classes == "character" | 
                            feature_classes == "factor"])
categorical_feats
```
Finally we use the R dummyvars function to do the hot encoding of the categorical variables and then we have filled with zeros the fields with Nan values. 
```{r}
dummies <- dummyVars(~.,feats2[categorical_feats])
categorical_1_hot <- predict(dummies,feats2[categorical_feats])
categorical_1_hot[is.na(categorical_1_hot)] <- 0

head(dummies)
head(categorical_1_hot)
```
To finish the pre-processing, we will merge the numerical data with the categorical data after the hot encoded in a data frame and the result will be saved in a file for the data modeling.
```{r}
final_data <- cbind(feats2[numeric_feats],categorical_1_hot)
write.csv(final_data, file="./data/Model_data.csv")
```





## 3 Model

### 3.1 Linear Regression Ridge and Lasso

### 3.2 SVM

## 4 References


